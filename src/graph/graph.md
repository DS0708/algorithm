# 그래프

## 그래프의 종류
- 간선의 방향 유무
  - 방향 그래프(directed graph) 혹은 유향 그래프 : 그래프의 간선이 방향이라는 속성을 가지며, 방향이 다르면 다른 간선으로 분류
  - 무향 그래프(undirected graph) : 그래프의 간선이 방향을 가지지 않으며, 두 정점을 잇는 간선은 하나의 간선으로 분류
- 가중치의 유무
  - 가중치 그래프(weighted graph) : 각 간선에 가중치(weight)라고 불리는 실수 속성을 부여한 것으로, 이 속성은 두 도시 사이의 거리, 두 물건 사이의 교환 비율 등 다양한 정보를 표현함
- 간선이 몇 개 존재하는지에 따라
  - 단순 그래프(simple graph) : 두 정점 사이에 최대 한 개의 간선만 있는 그래프
  - 다중 그래프(multigraph) : 두 정점 사이에 두 개 이상의 간선이 있을 수 있는 그래프
- 그 이외의 그래프
  - 트리 혹은 루트 없는 트리(unrooted tree) : 부모 자식 관계가 없을 뿐, 간선들의 연결 관계만 보면 트리와 같은 무향 그래프를 의미하며, 간선을 통해 두 정점을 잇는 방법이 딱 하나만 존재
  - 이분 그래프(bipartite graph) : 그래프의 정점들을 겹치지 않는 두 개의 그룹으로 나누어, 서로 다른 그룹에 속한 정점들 간에만 간선이 존재하도록 만들 수 있는 그래프
  - DAG(directed acyclic graph, 사이클 없는 방향 그래프) : 방향 그래프인데, 한 점에서 출발해 자기 자신으로 돌아오는 경로(사이클)이 존재하지 않는 그래프로, 
  간선의 방향을 무시할 경우 DAG에는 사이클이 존재할 수도 있다.

> 암시적 그래프(implicit graph) : 현실 세계에서 그래프 같은 형태를 갖는 구조가 아니라도 그래프를 통해서 표현하면 쉽게 해결할 수 있는 문제들이 종종 있는데, 이와 같은 그래프 구조를 암시적 그래프라고 함.

## 그래프의 경로
- 경로(path) : 끝과 끝이 서로 연결된 간선들을 순서대로 나열한 것, 예를 들어 1-2-3-4-5처럼 거쳐 가는 정점의 번호만을 써서 간단히 표기할 수 있음
- 단순 경로(simple path) : 경로 중 한 정점을 최대 한 번만 지나는 경로, 2-4-2-5는 2번 정점을 두 번 지나므로 단순 경로가 아니며, 현대 그래프 이론에서 경로라고 하면 대부분 단순 경로를 의미.
- 사이클(cycle) 혹은 회로 : 시작한 점에서 끝나는 경로, 1-2-3-4-1 은 싸이클임.

## 그래프의 표현 방법
- 인접 리스트(adjacency list) : 그래프의 각 정점마다 해당 정점에서 나가는 간선의 목록을 저장해서 그래프를 표현
    ```java
    List<Edge>[] graph = new ArrayList<>[V];
    ```
  - 장점 : O(V+E)만큼의 공간만 사용하므로 인접 행렬에 비해 메모리 효율적
  - 단점 : 두 정점이 주어질 떄 이 정점이 연결되어 있는 지를 알기 위해, 연결 리스트를 일일이 탐색해야 한다.
- 인접 행렬 : 인접 리스트의 단점을 보완하기 위해, 그래프를 V * V 크기의 행렬, 즉 2차원 배열을 이용해 그래프의 간선 정보를 저장
    ```java
    int[][] graph = new int[V][V];
    ```
  - 장점 : 정점의 번호 u,v가 주어졌을 때 두 정점을 잇는 간선이 있는지를 한 번의 배열 접근만으로 확인 가능
  - 단점 : V * V 의 2차원 배열을 사용하기 때문에 항상 O(V^2) 크기의 공간을 사용함
  
> 간선의 수가 V^2에 비해 훨씬 적은 그래프를 `희소 그래프(sparse graph)`라고 부르고, 반대로 간선의 수가 V^2에 비례하는 그래프를 `밀집 그래프(dense graph)`라고 부른다.
> 따라서 `희소 그래프에는 인접 리스트`를, `밀집 그래프에는 인접 행렬`을 사용하는 것이 유리하다.


## 깊이 우선 탐색

### 시간 복잡도
- 인접 행렬 : V번 탐색하는데, 각 V번마다 V개의 정점과 연결되어 있는지 확인해야 하므로 -> O(V^2)
- 인접 리스트 : V번 탐색하고, 전체 간선의 개수만 확인하면 되므로 -> O(V + E)

> 희소 그래프의 경우 인접 리스트를 사용하는 것이 훨씬 성능이 좋고, 밀접 그래프의 경우 인접 행렬과 인접 리스트 둘 다 시간 복잡도가 O(V^2)이므로 비슷하다.

### 깊이 우선 탐색으로 풀 수 있는 문제들
- 두 정점이 서로 연결되어 있는가 확인하기 : 어떤 정점 u에 대하여 dfs(u)를 수행하고 v를 방문했는지 보면 됨
- 연결된 부분 집합 개수 세기 : 각 정점에 대하여 for 문을 통해 dfs()를 실행시키고, dfs()가 실행되는 횟수를 세면 됨
- 위상 정렬 : 