# Greedy Algorithm (탐욕법)

## 동적 계획법과의 차이점
원하는 답을 재귀 호출과 똑같이 여러 개의 조각으로 쪼개고, 각 단계마다 답의 한 부분을 만들어 간다는 점에서 
완전 탐색이나 동적 계획법 알고리즘과 다를 것이 없지만, 모든 선택지를 고려해 보고 그중 전체 답이 가장 좋은 것을 찾는
두 방법과는 달리, 탐욕법은 각 단계마다 지금 당장 가장 좋은 방법만을 선택한다.

동적 계획법에 비해 빠르고 메모리 효율적이기 때문에, 동적계획법을 사용했을 때 시간이 부족하거나 메모리가 제한적이라면
Greedy Algorithm을 생각해볼 수 있다.

## Greedy Algorithm의 정당성의 증명
Greedy Algorithm의 정당성 증명은 대부분의 경우 일반적인 패턴을 가진다. 이러한 증명 패턴은 Greedy Algorithm이 
항상 최적해를 찾아낼 수 있다는 것을 두 가지의 속성(탐욕적 선택 속성, 최적 부분 구조)을 증명함으로써 보인다.

### Greedy Choice Property (탐욕적 선택 속성)
동적 계획법처럼 답의 모든 부분을 고려하지 않고 탐욕적으로만 선택하더라도 최적해를 구할 수 있다는 속성이다. 어떤 알고리즘에
이 속성이 성립할 경우, 우리가 각 단계에서 탐욕적으로 내리는 선택은 항상 최적해로 가는 길 중 하나이다.

보통 탐욕적 선택을 하지 않았을 때의 해와 비교하여 탐욕적 선택의 정당성을 증명한다.

### 최적 부분 구조 (Optimal Substructure)
탐욕적 선택 속성을 만족하면서 최적 부분 구조 또한 만족한다면, 우리가 적용하는 Greedy Algorithm은 최적해가
보장됨을 증명할 수 있다. 동적 계획법을 다룰 때 했듯이, 부분 문제의 최적해에서 전체 문제의 최적해를 만들 수 있음을
증명하면 된다.

보통 이 속성은 매우 자명해서 따로 증명할 필요가 없는 경우가 대부분이다.

## Greedy Algorithm 레시피
1. 문제의 답을 만드는 과정을 여러 조각으로 나눈다.
2. 각 조각마다 어떤 우선순위로 선택을 내려야할지 결정한다. 이에 대한 직관을 얻기 위해서는 예제 입력이나
그 외의 작은 입력을 몇 개 손으로 풀어보는 것이 효율적이다.
3. 어떤 방식이 동작할 것 같으면 두 가지의 속성을 증명해 본다.
   - 탐욕적 선택 속성: 항상 각 단계에서 우리가 선택한 답을 포함하는 최적해가 존재함을 보이면 된다. 이 증명은 대개 우리가 선택한
   답과 다른 최적해가 존재함을 가정하고, 이것을 조작해서 우리가 선택한 답을 포함하는 최적해로 바꿀 수 있음을 보이는 형태로 이루어진다.
   - 최적 부분 구조: 각 단계에서 항상 최적의 선택만을 했을 때 전체 최적해를 구할 수 있는지 여부를 증명한다. 다행히도 대개의 경우
   이 속성이 성립하는지 아닌지는 자명하게 알 수 있다.
