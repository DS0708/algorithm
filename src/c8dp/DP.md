# 동적 계획법 설계

## 메모이제이션 구현 패턴
- 항상 기저 사례를 제일 먼저 처리. 입력이 범위를 벗어난 경우 등을 기저 사례로 처리하면 cache[]의 범위를 벗어나는 접근을 피할 수 있음
- 함수의 반환 값이 항상 0 이상이라는 점을 이용해 cache[]를 모두 -1로 초기화

## 동적 계획법 레시피
1. 주어진 문제를 완전 탐색을 이용해 해결
2. 중복된 부분 문제를 한 번만 계산하도록 메모이제이션을 적용

## 최적화 문제 동적 계획법 레시피
1. 모든 답을 만들어 보고 그중 최적해의 점수를 반환하는 완전 탐색 알고리즘을 설계.
2. 전체 답의 점수를 반환하는 것이 아니라, 앞으로 남은 선택들에 해당하는 점수만을 반환하도록 부분 문제 정의를 바꿈.
3. 재귀 호출의 입력에 이전의 선택에 관련된 정보가 있다면 꼭 필요한 것만 남기고 줄인다. 문제에 최적 부분 구조가 성립할 경우에는 이전 선택에 관련된 정보를 완전히 없앨 수도 있음. 
여기서 목표는 가능한 한 중복되는 부분 문제를 많이 만드는 것. 입력의 종류가 줄어들 수록 더 많은 부분 문제가 중복되고, 따라서 메모이제이션을 최대한도로 활용 가능.
4. 입력이 배열이거나 문자열인 경우 가능하다면 적절한 변환을 통해 메모이제이션할 수 있도록 함.
5. 메모이제이션 적용

## 최적화 문제 동적 계획법 레시피 적용 예시 - 문제코드: trianglepath
1. 모든 경로를 만들어 보고 전체 합 중 최대치를 반환하는 완전 탐색 알고리즘 path1()을 만듦
2. path1()이 전체 경로의 최대 합을 반환하는 것이 아니라 (y,x) 이후로 만난 숫자들의 최대 합만을 반환하도록 바꿈
3. 이렇게 반환 값의 정의를 바꿨기 때문에 이전에 한 선택에 대한 정보인 sum을 입력 받을 필요가 없어짐. 이 정보를 받을 필요가 없는 것은 문제에 최적 부분 구조가 성립하기 때문.
4. 이 항목 불필요.
5. 메모이제이션 적용